---
layout: post
title:  "주문이 출고되기까지의 과정 (1)"
subtitle: "주문 수집부터 출고 이후의 과정까지 부스타에서 한 번에 관리하기"
author: sekim
category: tech
tags: [ 주문, 출고, WMS, 데이터 ]
image: assets/images/4.jpg
---

### 해당 포스트는..
> 부스타에서는 주문 입력과 수집부터, 출고 그리고 매출 집계까지의 과정이 모두 유기적으로 연동되어있습니다. 부스터스만의 출고 플로우가 궁금하시다면 끝까지 주목해주세요! (Feat. Isolation Level)

### 부스타만의 출고 프로세스가 탄생한 이유
3년이라는 짧은 업력동안 빠르게 성장한 부스터스는 2년 동안 WMS 시스템을 3번 변경하였습니다. 시스템을 변경할 때마다 해당 시스템에 맞춰 업무 플로우를 변경하고 적응하는 시간을 가져야하는 등 비효율적인 측면이 발생하였습니다. 이에 따라 데이터를 우리만의 방식으로 내재화하고 통합 관리하여 외부 시스템에 대한 의존성을 줄이자는 의견이 나왔고, 주문 수집부터 매칭까지의 단계를 부스타에서 진행할 수 있도록 하는 `부스터스만의 출고 플로우`가 탄생하게 되었습니다.


### 여러 채널에서 발생하는 주문 한 곳으로 통합하기

사진자리

고객의 주문은 매우 다양한 곳에서 발생합니다. 쿠팡, 11번가, 스마트스토어 등 수많은 온라인 채널에서 발생하는 주문들과 B2B 형태의 주문들을 모두 표준화하여 통합하는 작업이 필요합니다. 대부분의 채널들의 주문은 쇼핑몰 통합 관리 시스템을 통해 하나로 모이고, 모인 주문들은 쇼핑몰 통합 관리 시스템 API를 통해 부스타 DB로 수집됩니다. B2B 주문이나 샘플 출고 등의 주문은 부스타에서 엑셀 업로드를 통해 주문이 등록, 수집되고, 소셜미디어 공동구매 주문 건은 ERP 시스템에 등록이 되면 이를 재수집하는 형태로 주문 수집이 이루어집니다. 이처럼 제각기 다양한 형식을 가진 주문 데이터를 수집하고 표준화하여 DB에 저장하는 과정을 통해 출고 과정에서의 복잡성을 줄일 수 있습니다.

수집된 주문 데이터를 API를 통해 WMS에 전송하기 전에 부스타에서는 반드시 <b>주문 매칭</b>이 이루어집니다. <b>주문 매칭</b>이란 하나의 판매 구성안에 들어있는 품목을 선택하는 작업을 말합니다. 같은 판매 구성안이라도 채널에 따라 노출되는 실제 딜명이 다르기 때문에 새로운 딜명을 가진 주문이 들어올 때마다 매칭 작업이 이루어집니다. 이러한 매칭 정보를 담고 있는 매칭 정보 테이블이 구성되면, 해당 딜명의 주문이 들어올 때마다 매칭 정보 테이블에 의해 자동으로 매칭되어 WMS에 전송될 준비가 완료됩니다.

주문 수집 단계에서 통합된 데이터를 WMS로 전송하면 실제 출고가 이루어집니다.
수집되는 주문 데이터는 API를 통해 WMS로 전송됩니다. WMS는 수신된 주문 데이터를 바탕으로 재고를 할당하고, 피킹(picking) 작업을 지시하며 출고를 준비합니다. ????또한, WMS와의 연동을 통해 실시간으로 재고 상태를 파악할 수 있어, 재고 부족 등의 문제를 사전에 방지할 수 있습니다.???


### 왜 API 전송 프로세스가 중복으로 실행되면 안되는가?
주문 매칭까지 이루어진 데이터를 WMS 시스템에 전송하면 실제 출고가 이루어집니다. 이 단계부터는 출고, 즉 고객과 직접적으로 연결되는 단계이기 때문에 데이터 정합성 관리를 엄격하게 해주어야 합니다. 이러한 데이터의 정합성을 지키기 위해 MySQL의 격리수준을 사용하여 WMS에 API 전송이 중복 전송이 되지 않도록 방어하였습니다.


><b>트랜잭션의 격리 수준(Transaction Isolation Level)</b><br><br>
>여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것이다.<br>
>격리(고립) 수준이 높은 순서대로 SERIALIZABLE, REPEATABLE READ, READ COMMITTED, READ UNCOMMITED가 존재한다.<br>
>DIRTY READ라고도 하는 READ UNCOMMITED는 일반적인 데이터베이스에서는 거의 사용하지 않고, SERIALIZABLE 또한 동시성이 중요한 데이터베이스에서는 거의 사용되지 않는다.<br>

<p style="text-align: center;">
  <img src="/assets/images/2024-07/isolation_level.PNG" alt="트랜잭션 격리수준">
</p>


만약 격리수준이 따로 설정되어 있지 않은 데이터베이스라면, SELECT의 중복으로 인해 중복 데이터가 전송될 수 있습니다. 이를 막기 위해 트랜잭션 단위의 작업으로 쿼리 수행을 수정할 수 있습니다. 현재 부스타 DB에 적용되어 있는 <b>REPEATABLE READ</b>에 대한 조금 더 자세한 설명을 덧붙여보자면 아래와 같습니다.

<b>REPEATABLE READ</b>는 MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리수준입니다. Inno DB 스토리지 엔진은 트랜잭션이 Rollback 될 가능성에 대비해 변경되기 전 레코드를 언두(Undo)공간에 백업해두고 실제 레코드 값을 변경합니다. 동일한 레코드에 대해 여러 버전의 데이터가 존재하는 이러한 변경 방식을 MVCC(Multi Version Concurrency Control, 다중 버전 동시성 제어)라고 합니다. MVCC를 통해 트랜잭션이 롤백된 경우에 데이터를 복원할 수 있을 뿐만 아니라, 서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어할 수 있습니다.

REPEATABLE READ 방식을 이해하기 위해 쉬운 예시를 들어 설명해보자면 아래와 같습니다.
1. 트랜잭션 A가 실행 중입니다.
2. 트랜잭션 A가 시작한 후, 트랜잭션 B가 같은 데이터를 변경합니다.
3. 트랜잭션 A는 트랜잭션 B가 데이터를 변경했는지 알 수 없습니다.
4. 트랜잭션 A가 끝날 때까지 같은 데이터를 조회하면 항상 같은 결과가 반환됩니다.

위 표의 괄호 속 설명과 같이, Inno DB 스토리지 엔진에서는 REPEATABLE READ 수준에서 MVCC와 갭 락으로 인해 PHANTOM READ가 발생하지 않습니다.
> 갭 락(Gap lock) : 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것. 레코드와 레코드 사이의 간격에 새로운 레코드가 INSERT 되는 것을 제어하는 것이다.

위의 예시를 한 번 더 활용해 이번에는 갭 락에 대해 설명해보도록 하겠습니다.
1번 과정에서 트랜잭션 A가 실행되면 Inno DB에서는 해당 쿼리를 실행하면서 레코드 사이의 간격에 갭 락이 실행됩니다.
트랜잭션 B는 트랜잭션 A와 같은 데이터를 변경(예를 들어 삽입인 경우)하려하지만 갭 락으로 인해 해당 범위에 새로운 레코드를 삽입할 수 없습니다.
트랜잭션 A가 종료될 때까지 새로운 레코드가 삽입되지 않았기 때문에 조회 결과는 변하지 않았습니다.
=> PHANTOM READ 발생 X


결론 몇 줄 작성 예정

